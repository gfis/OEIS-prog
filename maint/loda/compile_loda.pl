#!perl

# Compile LODA programs into Java programs for jOEIS (with lpb,lpe, but no clr,seq)
# 2023-04-14: copied from gen_loda.pl
# 2023-04-12, Georg Fischer
#
#:# Usage:
#:#   perl compile_loda.pl extract_nyi.seq4 > output.seq4
#--------------------------------
use strict;
use integer;
use warnings;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime (time);
my $utc_stamp = sprintf ("%04d-%02d-%02dT%02d:%02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min, $sec) . "z";
if (0 and scalar(@ARGV) == 0) {
    print `grep -E "^#:#" $0 | cut -b3-`;
    exit;
}
my $loda_path = "../../../loda-programs/oeis";
my $debug  = 0; # 0 (none), 1 (some), 2 (more)
my %subset;
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{d}) {
        $debug     = shift(@ARGV);
    } elsif ($opt  =~ m{s}) {
        my $list   = shift(@ARGV);
        foreach my $instr (split(/\s*\,\s*/, $list)) {
            $subset{$instr} = 1;
        }
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt
my %jhash = qw(
    add add
    sub subtract
    mul multiply
    div divide
    pow pow
    );
my %znum = qw(
    -1 Z.NEG_ONE
    0  Z.ZERO
    1  Z.ONE
    2  Z.TWO
    3  Z.THREE
    4  Z.FOUR
    5  Z.FIVE
    6  Z.SIX
    7  Z.SEVEN
    8  Z.EIGHT
    9  Z.NINE
    10 Z.TEN
    );
my      ($aseqno, $callcode, $offset1, $name, $keyword, $range, $author, $formula, @lines, $instr_list);
my @methods; # buffer for inner methods generated by lpb...lpe
my $next_code;
my $imethod;
my $maxreg;
my %menhash; # hash for method names
my $letters = "abcdefghijklmnopqrstuvwxyz";
my $nok; # if record is not to be repeated
while (<>) { # read seq4 format
    $nok = 0; # assume success
    s/\s+\Z//; # chompr
    if (m{\AA\d{4}\d+\s}) { # starts with A.number
        ($aseqno, $callcode, $offset1, $instr_list, $formula, $name, $keyword, $range, $author) = split(/\t/);
        @methods = ();
        $imethod = 0;
        %menhash = ();
        my $code = &gener($instr_list);
        if ($nok eq "0") {
            $range =~ m{\A(\-?\d+)\.\.(\-?\d+)};
            my $offset1 = $1;
            # shift(@methods);
            my $method_list = "~~  " . join("~~  ~~", @methods);
            print        join("\t", $aseqno, "loda", $offset1, $method_list, $code, $formula, $name, $keyword, $range, $author) . "\n";
        } else {
            print STDERR join("\t", $aseqno, $name, $keyword, $range, $author, $nok) . "\n";
        }
    } # starts with A-number
} # while seq4

sub gener { # writes global $next_code, $methods[$imethod]
    my ($list) = @_;
    $list =~ s{\A\;}{}; # just in case that there is a leading ";"
    $maxreg = 0;
    my ($instr, $opnds, $op1, $op2, $line);
    @lines = map {
        $line = $_;
        foreach my $reg ($line =~ m{t(\d+)}g) {
            if ($reg > $maxreg) {
                $maxreg = $reg;
            }
        }
        $line;
    } split(/\;/, $list);
    # build the variable declarations
    $methods[$imethod] = "~~  ~~~~private Z t0 = Z.ZERO";
    for (my $ireg = 1; $ireg <= $maxreg; $ireg ++) {
        $methods[$imethod] .= ", t$ireg = Z.ZERO";
    } # for ireg
    $methods[$imethod] .= ";";
    my $code .=  "~~    ~~t0 = Z.valueOf(++mN);" . &expand_loop(0, scalar(@lines), 0, -1, ""); # recursively expand because of lpb/lpe; loopreg=0 for outmost level
    $code .= "~~return t0;";
    return $code;
} # gener
#--
sub expand_loop {
    my ($from, $to, $loopreg, $range, $indent) = @_;
    $loopreg =~ s{t}{};
    $range   =~ s{t}{}; # ???
    my $result = "";
    my $iline = $from;
    while ($iline < $to) {
        my $line = $lines[$iline];
        $line =~ m{\A([a-z]{3}) +(.*)};
        my $instr = $1;
        my $opnds = $2;
        my ($op1, $op2) = map {
            s/\$/t/;
            $_
        } split(/ *\, */, $opnds);
        if (0) {
        } elsif ($instr =~ m{mov}) {
            $result .= "~~${indent}$op1 = " . &valz($op2) . ";";
        } elsif ($instr =~ m{(add|sub|mul|div|pow)}) {
            $result .= "~~${indent}$op1 = $op1.$jhash{$instr}(" . &vali($op2) . ");"; # leave any constant
        } elsif ($instr =~ m{(bin)}) {
            $result .= "~~${indent}$op1 = Binomial.binomial($op1, " . &valz($op2) . ");"; # z-ify
        } elsif ($instr =~ m{(clr)}) {
            $result .= "~~${indent}// clear: $line";
            $op1 =~ s{t}{};
            $op2 =~ s{t}{}; # ???
            for (my $ireg = $op1; $ireg < $op1 + $op2; $ireg ++) {
                $result .= "~~${indent}t$ireg = Z.ZERO;";
            }
        } elsif ($instr =~ m{(cmp)}) { # equal ? 1 : 0
            $result .= "~~${indent}$op1 = $op1.equals(" . &valz($op2) . ") ? Z.ONE : Z.ZERO;"; # z-ify
        } elsif ($instr =~ m{(dif)}) { # divide only if divisible
            $result .= "~~${indent}if ($op1.mod(" . &valz($op2) . ").isZero()) {~~${indent}  $op1 = $op1.divide(" . &valz($op2) . ");~~${indent}}"; # z-ify
        } elsif ($instr =~ m{(gcd|min|max)}) {
            $result .= "~~${indent}$op1 = $op1.$instr(" . &valz($op2) . ");"; # z-ify
        } elsif ($instr =~ m{(mod)}) {
            $result .= "~~${indent}$op1 = $op1.$instr(" . &valz($op2) . ");"; # z-ify any constant
        } elsif ($instr =~ m{(trn)}) { # subtract, but remain >= 0
            $result .= "~~${indent}$op1 = $op1.subtract(" . &valz($op2) . ");~~${indent}if ($op1.compareTo(Z.ZERO) < 0) {~~${indent}  $op1 = Z.ZERO;~~${indent}}"; # z-ify
        } elsif ($instr =~ m{(lpb)}) { # always of the form "lpe ti,r" (with range)
            if (!defined($op2)) {
                $op2 = 1;
            }
            $op1 =~ s{t}{};
            $op2 =~ s{t}{}; # ???
            my @reglist = &search_lpe($iline); # index of correpsonding lpe, and list of modified registers
            my $ilpe = shift(@reglist);

            # build the call "loopxi();"
            $imethod ++; # push
            my  $suffix = 0;
            my  $method_name = "loop" . substr($letters, $suffix, 1) . "$imethod";
            while (defined($menhash{$method_name})) {
                $suffix ++;
                $method_name = "loop" . substr($letters, $suffix, 1) . "$imethod";
                print STDERR "$aseqno: method_name=$method_name";
            }
            $menhash{$method_name} = 1;
            $result .= "~~${indent}$method_name(); // $op1,$op2";

            # build the head of the called method
            $methods[$imethod] .= "~~private void $method_name() { // $op1,$op2";
            $methods[$imethod] .= "~~  " .   &assign_list("Z s", "t", join(",", @reglist), -1, -1) . " // init save"; # save all
            $methods[$imethod] .= "~~  boolean busy = true;~~  while(busy) {";

            # build the body of the called method
            $methods[$imethod] .= &expand_loop($iline + 1, $ilpe, $op1, $op2, "    ");

            # build the tail of the called method
            for (my $ireg = $op1; $ireg < $op1 + $op2; $ireg ++) {
                $methods[$imethod] .= "~~    t$ireg = t$ireg.subtract(1); // decr"; # decrement all in range
            } # for ireg
            $methods[$imethod] .= "~~    if"; 
            my $sep = "(";
            for (my $ireg = $op1; $ireg < $op1 + $op2; $ireg ++) {
                $methods[$imethod] .= $sep . "t$ireg.compareTo(Z.ZERO) < 0 || t$ireg.equals(s$ireg)"; # compare the range
                $sep = " || ";
            } # for ireg
            $methods[$imethod] .= ") {~~      busy = false;"; # start "if"
            $methods[$imethod] .= "~~      " . &assign_list("t", "s", join(",", @reglist), $op1, $op2) . " // rollback";
            $methods[$imethod] .= "~~    } else {";
            $methods[$imethod] .= "~~      " . &assign_list("s", "t", join(",", @reglist), -1, -1    ) . " // while save";
            $methods[$imethod] .= "~~    } // if"; # end of "if", "while"
            $methods[$imethod] .= "~~  } // while";
            $methods[$imethod] .= "~~} // $method_name"; # end of "if", "while"
            $imethod --; # pop
            $iline = $ilpe; # skip over all instructions inside the loop
        } elsif ($instr =~ m{(lpe)}) {
            # ignore
        } elsif ($instr =~ m{(seq)}) {
            print STDERR "** unimplemented instruction in $aseqno: $line\n";
            $nok .= "3";
            return $result . "~~${indent}return t0;";
        } else {
            print STDERR "** unknown instruction in $aseqno: $line\n";
            $nok .= "4";
            return $result . "~~${indent}return t0;";
        }
        $iline ++;
    } # while $iline
    # $result .= "~~${indent}return t0;";
    return $result;
} # expand_loop
#--
sub search_lpe {
    my ($ilpb) = @_; # index of lpb
    my %regs = ();
    my $level = 1;
    my $iline = $ilpb + 1;
    my $busy = 1;
    while ($busy && $iline < scalar(@lines)) {
        my $line = $lines[$iline];
        $line =~ m{\A([a-z]{3}) +(.*)};
        my $instr = $1;
        my $opnds = $2;
        my ($op1, $op2) = ($opnds =~ m{(\d+)}g);
        if (defined($op1)) {
            $regs{$op1} = 1;
        }
        if (0) {
        } elsif ($instr =~ m{\Alpb}) {
            $level ++;
        } elsif ($instr =~ m{\Alpe}) {
            $level --;
            if ($level <= 0) { # corrsponding lpe found
                $busy = 0; # break loop
            }
        }
        $iline ++;
    } # while
    if ($busy) { #
        print STDERR "** $aseqno: found no corresponding lpe for lpb at pc=$ilpb\n";
    }
    return ($iline - 1, sort(keys(%regs))); # index of corresponding lpe, and list of register numbers
} # search_lpe
#--
sub assign_list {
    my $result = "";
    my ($left, $right, $reglist, $loopreg, $range) = @_;
    foreach my $ireg (split(/\,/, $reglist)) {
        if ($loopreg < 0 || $ireg < $loopreg || $ireg >= $loopreg + $range) {
            $result .= "$left$ireg = $right$ireg; ";
        }
    } 
    return $result;
} # assign_list
#--
sub vali {
    my ($expr) = @_;
    if ($expr !~ m{\At}) {
        if (0) {
        } elsif (length($expr) > 16) {
            $expr = "new Z(\"$expr\")";
        } elsif (length($expr) > 8) {
            $expr .= "L";
        }
    }
    return $expr;
} # vali
#--
sub valz {
    my ($expr) = @_;
    if ($expr !~ m{\At}) {
        if (defined($znum{$expr})) {
            $expr = $znum{$expr};
        } elsif (length($expr) > 16) {
            $expr = "new Z(\"$expr\")";
        } elsif (length($expr) > 8) {
            $expr .= "L";
        } else {
            $expr = "Z.valueOf($expr)";
        }
    }
    return $expr;
} # valz
__DATA__
A000509 Size of second largest n-arc in PG(2,q), where q runs through the primes and prime powers >= 7. nonn,hard,more,nice,synth       1..12   J. W. P. Hirschfeld [
A000789 Maximal order of a triangle-free cyclic graph with no independent set of size n.        nonn,hard,more,changed,synth    2..12   _N. J. A. Sloane_
A000791 Ramsey numbers R(3,n).  nonn,hard,more,nice,changed,synth       2..9    _N. J. A. Sloane_

; A110695: Kekul√© numbers for certain benzenoids of trigonal symmetry.
; Submitted by zombie67 [MM]
; 1,9,341,14859,671509,31816259,1575219491,80813149559,4262996933909,229858972288659,12613108252122091,
073947022121799,129122621276859925669799,7464703283245663214517359,434337845911449017802222869,25416322
135899,88312804731272988307547408471399,5238627264019696883326719213745259,3118897999494000246798188816
,1116278354054563771137568867345238902799
; Formula: a(n) = 2*(((4*binomial(2*n,n)-2)*((2*binomial(2*n,n)-1)^2+3))/16)+1

mov $1,$0
mul $0,2
bin $0,$1
mul $0,2
sub $0,1
mov $2,$0
add $2,$0
pow $0,2
add $0,3
mul $0,$2
div $0,16
mul $0,2
add $0,1
