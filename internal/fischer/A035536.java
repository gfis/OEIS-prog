package irvine.oeis.a035;
// Generated by gen_seq4.pl A035536 0 0  at (DATE)
// DO NOT EDIT here!
/* 
    (maple), alois heinz:
    b := proc(n, i, c) option remember; `if`(n=0,
      `if`(c=0, 1, 0), `if`(i<1, 0, b(n, i-1, c)+
       b(n-i, min(n-i, i), c+[0, 1, -1][1+irem(i, 3)])))
    end:
    seq(b(n,n, 0), n=0..32);
__DATA__
1,0,0,2,0,0,6,0,0,14,0,0,32,0,0,66,0,0,134,0,0,256,0,0
,480,0,0,868,0,0,1540,0,0,2664,0,0,4536,0,0,7574,0,0
,12474,0,0,20234,0,0,32428,0,0,51324,0,0,80388,0,0,124582
,0,0,191310,0,0,291114,0,0,439394,0,0,657936,0,0
*/

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import java.util.HashMap;

/**
 * A035536 Number of partitions of n with equal number of parts congruent to each of 1 and 2 (mod 3)
 * @author Georg Fischer
 */
public class A035536 implements Sequence {

  private final HashMap<String, Z> mRemember; // simulate "option remember"
  protected final int[] mModules; // which combination of elements to select
  protected final int mImod; // take i mod this number
  protected int mN; // index of next term
  
  /** Construct with default parameters. */
  public A035536() {
    this(0, 3, 0,1,-1);
  }
    
  /** 
   * Construct the sequence. 
   * @param offset index of first term
   * @param imod take i mod this number
   * @param modules vector of valid values
   */
  public A035536(final int offset, int imod, int ... modules) {
    mImod = imod;
    mModules = modules;
    mRemember = new HashMap<String, Z>(1000000); // termNO = 1000 consumes some 6 mio hash map entries
    mN = offset - 1;
  }
    
  /**
   * Recursively evaluate all partitions and accumulate information for the condition
   * @param n number to be partitioned
   * @param i nesting level
   * @param t first accumulator
   * @return number of partitions of n with this condition 
   */
  protected Z partition (final int n, final int i, final int t) {
    final String key = String.valueOf(n) + "," + String.valueOf(i) + "," + String.valueOf(t); // String.format is much slower?
    Z result = mRemember.get(key);
    if (result == null) {
        if (n == 0) {
            result = (t == 0 ? Z.ONE : Z.ZERO);
        } else {
            if (i < 1) {
                result = Z.ZERO;
            } else {
                final int n_i = n - i;
                result = partition(n, i - 1, t)
                    .add(partition(n_i, n_i < i ? n_i : i, t + mModules[(int) i % mImod]));
            }
        }
        mRemember.put(key, result);
    }
    return result;
  }
  
  /**
   * Compute the next term of the sequence
   * @return a specific number of partitions
   */
  @Override
  public Z next() {
    ++mN;
    return partition(mN, mN, 0);
  }
}
