package irvine.oeis.a058;
// Generated by gen_seq4.pl eulerps -1 at 2020-11-06 09:55
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.EulerTransform;
import irvine.oeis.PeriodicSequence;
import irvine.oeis.Sequence;

/**
 * A058505 McKay-Thompson series of class 14a for Monster.
 * Uses <code>e14b=ecalc([1,1;7,-1],[2,2])</code> from A058506=A with ET[-2,-2,-2,-2,-2,-2,0]-
 * The sequence here is <code>A - 7*q/A</code>.
 *  
 * @author Georg Fischer
 */
public class A058505 implements Sequence {

  protected static final int DEBUG = 0;
  protected EulerTransform mET1; // the first sequenc
  protected EulerTransform mET2; // the second sequence
  protected int mSpread; // number of zeroes - 1 to be removed from the resulting sequence
  protected Z mFactor; // multiply the second sequence by this factor before addition
  protected Z mAdd0; // add this constant to the first resulting term
  protected int mN; // current index/offset
  protected int mOffset; // index of first term of the sequence
  
  /** Construct the sequence. */
  public A058505() {
    this(-1,2,-7,0,    0,-2,0,-2,0,-2,0,-2,0,-2,0,-2,0,0);
  }

  /** 
   * Constructor with parameters. 
   * @param offset index of first term of the sequence
   * @param spread number of zeroes - 1 to be removed from the resulting sequence
   * @param per1 the terms of the PeriodicSequence to be transformed
   * @param factor multiply the second sequence by this factor
   * @param add0 constant to be added to a(0)
   */
  public A058505(final int offset, final int spread, final long factor, final long add0, final long ... per1) {
    mET1 = new EulerTransform(new PeriodicSequence(per1), 1);
    long[] per2 = new long[per1.length];
    for (int k = 0; k < per1.length; ++k) {
      per2[k] = - per1[k]; // negate per1
    }
    mET2 = new EulerTransform(new PeriodicSequence(per2), 1);
    mSpread = spread;
    mFactor = Z.valueOf(factor);
    mAdd0 = Z.valueOf(add0);
    mOffset = offset;
    mN = offset - 1;
  }
  
  @Override
  public Z next() {
    ++mN; // starts with offset
    Z et1 = null;
    Z et2 = null;
    if (mN == mOffset) {
      return mET1.next();
    } else {
      for (int iSpread = mSpread - 1; iSpread > 0; --iSpread) { // skip zeroes
        et1 = mET1.next();
        if (DEBUG > 0) { System.out.println("skip et1=" + et1); }
      } // for skip
      et1 = mET1.next();
      et2 = mET2.next();
      if (DEBUG > 0) { System.out.println("add et1=" + et1 + " + " + mFactor + "*" + "et2=" + et2); }
      Z result = et1.add(et2.multiply(mFactor));
      if (mN == 0) {
        result = result.add(mAdd0);
      }
      for (int iSpread = mSpread - 1; iSpread > 0; --iSpread) { // skip zeroes
        et2 = mET2.next();
        if (DEBUG > 0) { System.out.println("skip et2=" + et2); }
      } // for skip
      return result;
    }
  }
  
}
