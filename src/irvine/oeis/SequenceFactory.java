package irvine.oeis;
// 2019-05-09, Georg Fischer: joeis-lite version, writes b-file format

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import irvine.math.z.Z;
import irvine.oeis.DeadSequence;
import irvine.oeis.Sequence;
import irvine.util.string.Casing;
import irvine.util.string.StringUtils;

/**
 * A factory providing methods to get an object capable to generating a
 * specified sequence in the OEIS.
 * @author Sean A. Irvine
 */
public final class SequenceFactory {

  private SequenceFactory() { }
  private static Set<String> sDead = null;
  private static final Sequence DEAD_SEQUENCE = new DeadSequence();

  private static synchronized boolean isDead(final String aNumber) {
    if (sDead == null) {
      try {
        sDead = new HashSet<>(StringUtils.suckInWords(SequenceFactory.class.getResourceAsStream("/irvine/oeis/dead.lst"), Casing.NONE));
      } catch (final IOException e) {
        throw new RuntimeException(e);
      }
    }
    return sDead.contains(aNumber);
  }

  /**
   * Return the sequence for the specified id. The sequence is not
   * known then <code>UnsupportedOperationException</code> is thrown.
   *
   * @param seqId sequence identifier in the form <code>A000001</code>
   * @return sequence for id
   * @exception UnsupportedOperationException for an unknown
   * <code>seqId</code>.
   */
  public static Sequence sequence(final String seqId) {
    if (seqId != null && seqId.length() > 1 && seqId.charAt(0) == 'A') {
      final String canonicalId;
      if (seqId.length() < 7) {
        // Pad out number to correct format
        canonicalId = "A000000".substring(0, 8 - seqId.length()) + seqId.substring(1);
      } else {
        canonicalId = seqId;
      }
      try {
        return (Sequence) Class.forName("irvine.oeis.a" + canonicalId.substring(1, 4) + '.' + canonicalId).newInstance();
      } catch (final ClassNotFoundException | IllegalAccessException | InstantiationException e) {
        if (isDead(canonicalId)) {
          return DEAD_SEQUENCE;
        }
        throw new UnsupportedOperationException();
      }
    }
    throw new UnsupportedOperationException();
  }

  /**
   * Generate terms from specified sequence, writing a b-file with one term per line
   * @param args sequence identifier, number of terms, offset1
   */
  public static void main(final String[] args) {
    if (args == null || args.length == 0) {
      System.err.println("Usage: SequenceFactory sequence-id [no-terms [offset1]]");
      return;
    }
    boolean generated = false;
    try {
      int iarg = 0;
      final String aseqno = args[iarg ++];
      final Sequence seq = sequence(args[0]);
      Z z;
      if (iarg == args.length) { // only 1 argument - print terms only
        while ((z = seq.next()) != null) {
          generated = true;
          System.out.println(z.toString());
          System.out.flush();
        }
      } else { // >= 2 arguments - write b-file format
        int nterms  = 32; // default
        int offset1 = 1;
        try {
          nterms = Integer.parseInt(args[iarg ++]);
          if (iarg < args.length) {
            offset1 = Integer.parseInt(args[iarg ++]);
          } 
        } catch (Exception exc) { 
          // ignore and take defaults
        } 
        int iterm = offset1;
        final int ilast = iterm + nterms - 1;
        System.out.println("# Table of n, a(n) for n = " + offset1 + ".." + ilast);
        System.out.println("# Generated by jOEIS "
            + (new SimpleDateFormat("MMM dd yyyy")).format(new java.util.Date()));
        while (iterm <= ilast && (z = seq.next()) != null) {
          generated = true;
          System.out.println(String.valueOf(iterm) + " " + z.toString()); // b-file format
          iterm ++;
          System.out.flush();
        } // while iterm
        System.out.println(); // convention is: one additional newline
        System.out.flush();
      } // >= 2 arguments
    } catch (final UnsupportedOperationException e) {
      if (generated) {
        System.err.println("Implementation limits exceeded, cannot generate further terms for " + args[0] + "\n" + e.getMessage());
      } else {
        System.err.println(args[0] + " is not yet implemented");
      }
    } catch (final Exception e) {
      // Catch nasty shutdown exception from Apfloat and just ignore it
      if (!"Shutdown in progress".equals(e.getMessage())) {
        throw e;
      }
    }
  }
}

